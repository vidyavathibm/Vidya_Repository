import unittest:
def sum_digit(li):
  sum=0
  for i in li:
    if type(i)==int:
      sum=sum+i
    elif i.isdigit():
      sum=sum+int(i)
  print("The sum of digits of a number is ",sum)

sum_digit([22,'none','hai',33,'22'])

class Sample_Test(Unittest.TestCase):
_________________________________________________________________________________________

https://pymbook.readthedocs.io/en/latest/igd.html
https://www.guru99.com/hive-queries-implementation.html
https://ajaypratapsingh.wordpress.com/2017/08/07/hive-interview-questions/
https://pymbook.readthedocs.io/en/latest/pep8.html
https://www.edureka.co/blog/python-database-connection/

PFB the answers:

1. Difference between "Sort By" and "Group by" in Hive. How they work?
Ans. SORT BY sorts the data per reducer, it provides ordering of the rows within a reducer. If there are more than one reducer, "sort by" may give partially ordered final results. Whereas GROUP BY aggregate records by the specified columns which allows you to perform aggregation functions on non-grouped columns (such as SUM, COUNT, AVG, etc).

2. If we use the "Limit 1" in any SQL query in Hive, will Reducer work or not.
Ans. I think Reducer will work, because as per Hive documentation -- Limit indicates the number of rows to be returned. The rows returned are chosen at random. The following query returns 5 rows from t1 at random.

SELECT * FROM t1 LIMIT 5
Having to randomly pick, it has to have complete result output from Reducer.

- How to optimize Hive Performance?
Ans. These links should answer this

- Difference between "Internal Table" and "External Table"
Ans. "Internal Table" also known as Managed Table, is the one that is managed by Hive. When you point data in HDFS to such table, the data is moved to Hive default location /ust/hive/warehouse/. And, then if such internal table is dropped, the data is deleted along with.

"External table" on the other hand is user managed, and data is not moved to hive default directory after loading i.e, any custom location can be specified. Consecutively, when you drop such table, no data is deleted, only table schema is dropped.

- What is the main difference between Hive and SQL
Ans. Hive is a Datawarehousing layer on top of hadoop that provides SQL like row table interface to users for analyzing underlying data. It employs HiveQL (HQL) language for this which is loosely based on SQL-92 standards.

SQL is a standard RDBMS language for accessing and manipulating databases.

Internal table : Both metadata and data stored in the hive. If one deletes the table, automatically entire schema and data would be deleted.
External table : Only metadata is handled by hive. Data is handled by user. If one deletes the table , only schema will be deleted, data remains intact. 
For creation of external table , one needs to use external keyword in create statement and also needs to specify the location where data is put.



# li=[]
# li.append([10,20,30])
# li.append('vidhu')
# print(li)
# li.extend('bharuu')
# print(li)
# c=range(10,20)
# iterator=iter(c)
# print(iterator)


# while(True):
#   i=iterator.__next__()
#   print(i)

# li=sum(x for x in range(1,10))
# print(li)
# li=sum([x for x in range(1,10)])
# print(li)


# def mydecorator(func):
#   def wrapper(*args):
#     print("Before call")
#     result=func(*args)
#     print(result)
#     print("After call")
#     return result
#   return wrapper

# @mydecorator
# def add(a,b):
#   return a+b

# add(10,20)

# list1=[10,20,30,40]
# iter_list=iter(list1)
# while(True):
#   try:
#     print(iter_list.next())
#   except StopIteration:
#     print("End of list")
#     break


# for e in list1:

#   print(e)


# class PowTwo:
#   def __init__(self,max):
#     self.max=max

#   def __iter__(self):
#     self.n=0
#     return self.n

#   def __next__(self):
#     if self.n<=self.max:
#       result=2**self.n
#       self.n+=1
#       return result
#     else:
#       raise StopIteration

# a=PowTwo(4)
# iterator=iter(a)
# print(iterator.next())

# for i in PowTwo(5):
#   print(i)

# class InfIter:
    
#     def __iter__(self):
#         self.num = 1
#         return self

#     def __next__(self):
#         num = self.num
#         self.num += 2
#         return num
# a = iter(InfIter())
# next(a)

# def my_gen(mystr):
  
#   for i in range(len(mystr)-1,-1,-1):
#     yield mystr[i]

# a=my_gen("hello")
# for i in a:
#   print(i)


# mylist=[10,20,30,40]

# ge=(x**2 for x in mylist)
# for i in ge:
#   print(i)
